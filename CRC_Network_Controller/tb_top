`timescale 1ns/1ps

module tb_top;

    reg clk;
    reg rst_n;

    initial begin
        clk = 0;
        forever #10 clk = ~clk;   // 50MHz
    end

    initial begin
        rst_n = 0;
        #50;
        rst_n = 1;
    end


    // ID 조건
    localparam [1:0] TX_ID = 2'b10;
    localparam [1:0] RX_ID = 2'b11;

    // header
    // destination=11, source=10, length=0000 => 1110_0000 = 8'hE0
    localparam [7:0] HEADER_E0 = 8'hE0;

    // destination 불일치 : destination=01, source=10, length=0000 => 0110_0000 = 8'h60
    localparam [7:0] HEADER_60 = 8'h60;

    // TX 
    reg         tx_start;
    reg [135:0] tx_packet;
    reg         test_mode;
    wire        tx_line;

    // RX
    wire [1:0]   rx_dest_id;
    wire [1:0]   rx_src_id;
    wire [127:0] rx_payload;
    wire         frame_valid;
    wire         crc_error;

    // invalid_packet
    reg invalid_packet;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            invalid_packet <= 1'b0;
        else if (frame_valid) begin
            if (rx_dest_id != RX_ID) invalid_packet <= 1'b1;
            else                     invalid_packet <= 1'b0;
        end
    end

    // DUTs
    tx_transmitter u_tx (
        .clk       (clk),
        .rst_n     (rst_n),
        .tx_start  (tx_start),
        .tx_packet (tx_packet),
        .tx_line   (tx_line),
        .test_mode (test_mode)
    );

    rx_receiver u_rx (
        .clk        (clk),
        .rst_n      (rst_n),
        .rx_line    (tx_line),
        .dest_id    (rx_dest_id),
        .src_id     (rx_src_id),
        .payload    (rx_payload),
        .frame_valid(frame_valid),
        .crc_error  (crc_error)
    );

    // 프레임 전송 task
    task send_frame_bytes;
        input [7:0] header_byte;      
        input [7:0] first_data_byte;
        input       tmode;

        reg prev_fv, prev_ce;
        integer timeout;
        begin
            prev_fv = frame_valid;
            prev_ce = crc_error;

            tx_packet = {header_byte, {first_data_byte, 120'd0}};
            test_mode = tmode;

            // start 1clock pulse
            @(posedge clk); tx_start = 1'b1;
            @(posedge clk); tx_start = 1'b0;

            // 결과 플래그 변화 대기
            timeout = 0;
            while (((frame_valid == prev_fv) && (crc_error == prev_ce)) && (timeout < 20000)) begin
                @(posedge clk);
                timeout = timeout + 1;
            end
            repeat(10) @(posedge clk);
        end
    endtask


    // Test sequence
    initial begin
        tx_start  = 0;
        tx_packet = 0;
        test_mode = 0;

        @(posedge rst_n);
        repeat(5) @(posedge clk);

        // 1) 정상 프레임

        send_frame_bytes(HEADER_E0, 8'h57, 1'b0);

        // 2) test_mode 프레임
        send_frame_bytes(HEADER_E0, 8'h57, 1'b1); 

        // 3) invalid_packet
        send_frame_bytes(HEADER_60, 8'h57, 1'b0);

        #200;
        $stop;
    end

endmodule
