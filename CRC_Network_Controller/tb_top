`timescale 1ns/1ps

module tb_top;

    reg clk;
    reg rst_n;

    initial begin
        clk = 0;
        forever #10 clk = ~clk;
    end

    initial begin
        rst_n = 0;
        #50 rst_n = 1;
    end

    reg [4:0] clk_divide;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) clk_divide <= 5'd0;
        else        clk_divide <= clk_divide + 1'b1;
    end

    localparam [1:0] RX_ID = 2'b10;

    localparam [7:0] HEADER_OK      = 8'hB0;
    localparam [7:0] HEADER_INVALID = 8'h70;
    localparam [7:0] PAYLOAD_57     = 8'h57;

    reg         tx_start;
    reg [135:0] tx_packet;
    reg         test_mode;
    wire        tx_line;

    wire [1:0]   rx_dest_id;
    wire [1:0]   rx_src_id;
    wire [127:0] rx_payload;
    wire         frame_valid;
    wire         crc_error;

    tx_transmitter u_tx (
        .clk       (clk_divide[4]),
        .rst_n     (rst_n),
        .tx_start  (tx_start),
        .tx_packet (tx_packet),
        .tx_line   (tx_line),
        .test_mode (test_mode)
    );

    rx_receiver u_rx (
        .clk         (clk_divide[4]),
        .rst_n       (rst_n),
        .rx_line     (tx_line),
        .dest_id     (rx_dest_id),
        .src_id      (rx_src_id),
        .payload     (rx_payload),
        .frame_valid (frame_valid),
        .crc_error   (crc_error)
    );

    // ======================================================
    // INVALID PACKET (단순 / 확실 / 정석)
    // ======================================================
    wire invalid_packet;
    assign invalid_packet = frame_valid && (rx_dest_id != RX_ID);

    // ======================================================
    // (옵션) 관찰용 snapshot – 굳이 안 써도 됨
    // ======================================================
    reg [127:0] rx_payload_snap;
    reg         crc_error_snap;

    always @(posedge clk_divide[4] or negedge rst_n) begin
        if (!rst_n) begin
            rx_payload_snap <= 0;
            crc_error_snap  <= 0;
        end else if (frame_valid) begin
            rx_payload_snap <= rx_payload;
            crc_error_snap  <= crc_error;
        end
    end

    // ======================================================
    // Test sequence
    // ======================================================
    initial begin
        tx_start  = 0;
        test_mode = 0;
        tx_packet = 0;

        @(posedge rst_n);

        // CASE 1: NORMAL
        tx_packet = {HEADER_OK, {PAYLOAD_57, 120'd0}};
        #50_000;
        tx_start = 1;
        #1_000;
        tx_start = 0;
        #200_000;

        // CASE 2: CRC ERROR
        tx_packet = {HEADER_OK, {PAYLOAD_57, 120'd0}};
        test_mode = 1;
        #50_000;
        tx_start = 1;
        #1_000;
        tx_start = 0;
        #100_000;
        test_mode = 0;
        #200_000;

        // CASE 3: INVALID PACKET
        tx_packet = {HEADER_INVALID, {PAYLOAD_57, 120'd0}};
        #50_000;
        tx_start = 1;
        #1_000;
        tx_start = 0;
        #200_000;

        $stop;
    end

endmodule
